import AtRule from './at-rule.js'
import Comment from './comment.js'
import Declaration from './declaration.js'
import Node, { ChildNode, ChildProps, NodeProps } from './node.js'
import Rule from './rule.js'

declare namespace Container {
  export class ContainerWithChildren<
    Child extends Node = ChildNode
  > extends Container_<Child> {
    nodes: Child[]
  }

  export interface ValueOptions {
   
    fast?: string

    props?: readonly string[]
  }

  export interface ContainerProps extends NodeProps {
    nodes?: readonly (ChildProps | Node)[]
  }

 
  export type NewChild =
    | ChildProps
    | Node
    | readonly ChildProps[]
    | readonly Node[]
    | readonly string[]
    | string
    | undefined

  export { Container_ as default }
}

declare abstract class Container_<Child extends Node = ChildNode> extends Node {

  nodes: Child[] | undefined


  get first(): Child | undefined

 
  get last(): Child | undefined
  /**
   * @param nodes 
   * @return 
   */
  append(...nodes: Container.NewChild[]): this
  assign(overrides: Container.ContainerProps | object): this
  clone(overrides?: Partial<Container.ContainerProps>): this

  cloneAfter(overrides?: Partial<Container.ContainerProps>): this

  cloneBefore(overrides?: Partial<Container.ContainerProps>): this
  /**
   * @param callback 
   * @return 
   */
  each(
    callback: (node: Child, index: number) => false | void
  ): false | undefined

  /**
  
   * @param condition 
   * @return
   */
  every(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean
  /**
   * @param child 
   * @return
   */
  index(child: Child | number): number

  /**
   * @param oldNode 
   * @param newNode 
   * @return 
   */
  insertAfter(oldNode: Child | number, newNode: Container.NewChild): this

  /**
   * @param callback 
   * @return
   */

  /**
   * @param oldNode 
   * @param newNode 
   * @return 
   */
  insertBefore(oldNode: Child | number, newNode: Container.NewChild): this
  /**
   * @param nodes 
   * @return 
   */
  prepend(...nodes: Container.NewChild[]): this

  /**
   * @param child
   * @return 
   */
  push(child: Child): this

  /**
   * @return 
   */
  removeAll(): this

  /**
   * @param child 
   * @return 
   */
  removeChild(child: Child | number): this

  replaceValues(
    pattern: RegExp | string,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this
  /**
   * @param pattern      
   * @param {object} options           
   * @param replaced   
   *                                    
   * @return 
   */
  replaceValues(
    pattern: RegExp | string,
    options: Container.ValueOptions,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this

  /**
   * @param condition 
   * @return 
   */
  some(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean

  /**
   * @param callback
   * @return 
   */
  walk(
    callback: (node: ChildNode, index: number) => false | void
  ): false | undefined

  /**
 
   * @param name    
   * @param callback 
   * @return 
   */
  walkAtRules(
    nameFilter: RegExp | string,
    callback: (atRule: AtRule, index: number) => false | void
  ): false | undefined
  walkAtRules(
    callback: (atRule: AtRule, index: number) => false | void
  ): false | undefined

  walkComments(
    callback: (comment: Comment, indexed: number) => false | void
  ): false | undefined
  walkComments(
    callback: (comment: Comment, indexed: number) => false | void
  ): false | undefined

  /**
   * @param prop    
   * @param callback 
   * @return 
   */
  walkDecls(
    propFilter: RegExp | string,
    callback: (decl: Declaration, index: number) => false | void
  ): false | undefined
  walkDecls(
    callback: (decl: Declaration, index: number) => false | void
  ): false | undefined
  /**
   * @param selector
   * @param callback 
   * @return 
   */
  walkRules(
    selectorFilter: RegExp | string,
    callback: (rule: Rule, index: number) => false | void
  ): false | undefined
  walkRules(
    callback: (rule: Rule, index: number) => false | void
  ): false | undefined
  /**
 {@link NewChild} 
   * @param mnodes
   * @param sample 
   * @param type  
   * @hidden
   */
  protected normalize(
    nodes: Container.NewChild,
    sample: Node | undefined,
    type?: 'prepend' | false
  ): Child[]
}

declare class Container<
  Child extends Node = ChildNode
> extends Container_<Child> {}

export = Container
