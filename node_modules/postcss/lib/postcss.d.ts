import { RawSourceMap, SourceMapGenerator } from 'source-map-js'

import AtRule, { AtRuleProps } from './at-rule.js'
import Comment, { CommentProps } from './comment.js'
import Container, { ContainerProps, NewChild } from './container.js'
import CssSyntaxError from './css-syntax-error.js'
import Declaration, { DeclarationProps } from './declaration.js'
import Document, { DocumentProps } from './document.js'
import Input, { FilePosition } from './input.js'
import LazyResult from './lazy-result.js'
import list from './list.js'
import Node, {
  AnyNode,
  ChildNode,
  ChildProps,
  NodeErrorOptions,
  NodeProps,
  Position,
  Source
} from './node.js'
import Processor from './processor.js'
import Result, { Message } from './result.js'
import Root, { RootProps } from './root.js'
import Rule, { RuleProps } from './rule.js'
import Warning, { WarningOptions } from './warning.js'

type DocumentProcessor = (
  document: Document,
  helper: postcss.Helpers
) => Promise<void> | void
type RootProcessor = (
  root: Root,
  helper: postcss.Helpers
) => Promise<void> | void
type DeclarationProcessor = (
  decl: Declaration,
  helper: postcss.Helpers
) => Promise<void> | void
type RuleProcessor = (
  rule: Rule,
  helper: postcss.Helpers
) => Promise<void> | void
type AtRuleProcessor = (
  atRule: AtRule,
  helper: postcss.Helpers
) => Promise<void> | void
type CommentProcessor = (
  comment: Comment,
  helper: postcss.Helpers
) => Promise<void> | void

interface Processors {
  
  AtRule?: { [name: string]: AtRuleProcessor } | AtRuleProcessor

  AtRuleExit?: { [name: string]: AtRuleProcessor } | AtRuleProcessor

  Comment?: CommentProcessor


  CommentExit?: CommentProcessor

 
  Declaration?: { [prop: string]: DeclarationProcessor } | DeclarationProcessor

  
  DeclarationExit?:
    | { [prop: string]: DeclarationProcessor }
    | DeclarationProcessor

  Document?: DocumentProcessor

 
  DocumentExit?: DocumentProcessor

  Once?: RootProcessor

 
  OnceExit?: RootProcessor

  Root?: RootProcessor

  
  RootExit?: RootProcessor

  Rule?: RuleProcessor

  RuleExit?: RuleProcessor
}

declare namespace postcss {
  export {
    AnyNode,
    AtRule,
    AtRuleProps,
    ChildNode,
    ChildProps,
    Comment,
    CommentProps,
    Container,
    ContainerProps,
    CssSyntaxError,
    Declaration,
    DeclarationProps,
    Document,
    DocumentProps,
    FilePosition,
    Input,
    LazyResult,
    list,
    Message,
    NewChild,
    Node,
    NodeErrorOptions,
    NodeProps,
    Position,
    Processor,
    Result,
    Root,
    RootProps,
    Rule,
    RuleProps,
    Source,
    Warning,
    WarningOptions
  }

  export type SourceMap = {
    toJSON(): RawSourceMap
  } & SourceMapGenerator

  export type Helpers = { postcss: Postcss; result: Result } & Postcss

  export interface Plugin extends Processors {
    postcssPlugin: string
    prepare?: (result: Result) => Processors
  }

  export interface PluginCreator<PluginOptions> {
    (opts?: PluginOptions): Plugin | Processor
    postcss: true
  }

  export interface Transformer extends TransformCallback {
    postcssPlugin: string
    postcssVersion: string
  }

  export interface TransformCallback {
    (root: Root, result: Result): Promise<void> | void
  }

  export interface OldPlugin<T> extends Transformer {
    (opts?: T): Transformer
    postcss: Transformer
  }

  export type AcceptedPlugin =
    | {
        postcss: Processor | TransformCallback
      }
    | OldPlugin<any>
    | Plugin
    | PluginCreator<any>
    | Processor
    | TransformCallback

  export interface Parser<RootNode = Document | Root> {
    (
      css: { toString(): string } | string,
      opts?: Pick<ProcessOptions, 'document' | 'from' | 'map'>
    ): RootNode
  }

  export interface Builder {
    (part: string, node?: AnyNode, type?: 'end' | 'start'): void
  }

  export interface Stringifier {
    (node: AnyNode, builder: Builder): void
  }

  export interface JSONHydrator {
    (data: object): Node
    (data: object[]): Node[]
  }

  export interface Syntax<RootNode = Document | Root> {

    parse?: Parser<RootNode>

    
    stringify?: Stringifier
  }

  export interface SourceMapOptions {
 
    absolute?: boolean


    annotation?: ((file: string, root: Root) => string) | boolean | string

    from?: string

    inline?: boolean

 
    prev?: ((file: string) => string) | boolean | object | string

    
    sourcesContent?: boolean
  }

  export interface ProcessOptions<RootNode = Document | Root> {
   
    document?: string

    from?: string | undefined

    map?: boolean | SourceMapOptions

    parser?: Parser<RootNode> | Syntax<RootNode>

    stringifier?: Stringifier | Syntax<RootNode>

 
    syntax?: Syntax<RootNode>

   
    to?: string
  }

  export type Postcss = typeof postcss

 
  export let stringify: Stringifier

 
  export let parse: Parser<Root>


  export let fromJSON: JSONHydrator

  /**
   * @param defaults
   * @return 
   */
  export function comment(defaults?: CommentProps): Comment

  /**
  
   * @param defaults 
   * @return 
   */
  export function atRule(defaults?: AtRuleProps): AtRule

  /**

   * @param defaults 
   * @return 
   */
  export function decl(defaults?: DeclarationProps): Declaration

  /**
  
   * @param default 
   * @return 
   */
  export function rule(defaults?: RuleProps): Rule

  /**

   * @param defaults 
   * @return 
   */
  export function root(defaults?: RootProps): Root

  /**
   * @param defaults 
   * @return 
   */
  export function document(defaults?: DocumentProps): Document

  export { postcss as default }
}

/**
 * @param plugins
 * @return 
 */
declare function postcss(
  plugins?: readonly postcss.AcceptedPlugin[]
): Processor
declare function postcss(...plugins: postcss.AcceptedPlugin[]): Processor

export = postcss
